Test date: 07/14/16  20:45:57 
The number of times you used the grading program is 10 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
ARM Grading System Version 4.1
Student: Last=Marks                First=Collin               Type=Individual          
Grading program history
   *** Grading Run.  Date: 07/14/16  19:26:40 
   ************************************************** 
   *** Program works correctly.                       
   *** Additional runs are to improve efficiency.     
   *** Completion -- Date: 07/14/16  19:29:38                     
   ************************************************** 
   *** Grading Run.  Date: 07/14/16  19:29:40 
   *** Grading Run.  Date: 07/14/16  19:34:02 
   *** Grading Run.  Date: 07/14/16  19:34:41 
   *** Grading Run.  Date: 07/14/16  19:36:27 
   *** Grading Run.  Date: 07/14/16  19:43:25 
   *** Grading Run.  Date: 07/14/16  20:13:43 
   *** Grading Run.  Date: 07/14/16  20:24:59 
   *** Grading Run.  Date: 07/14/16  20:26:46 
   *** Grading Run.  Date: 07/14/16  20:45:57 
Comparing your program's key.out to the expected output
Test ran correctly.
++ Grade ++   60 = Points earned for correct answers.

-> A major reason for programming in assembler is to maximize efficiency.
This can be instructions written and/or instructions executed.
Please read the section in the class notes titled Code Complexity.

We are now analyzing your source code. You will be graded on
the number of instructions you wrote to solve this problem.
The target for the number of executable instructions written is:
20 points for   0 -  38  
15 points for  39 -  42  
10 points for  43 -  46 
05 points for  47 -  50 
00 points for  51+      
Your actual counts are:
Lines ....... 148    Comments ...  82    Labels .......   8   
Directives ..   9    Variables ..   7    Executables ..  42    McCabe ..   6 
++ Grade ++   15 = Points earned for code written efficiency.  

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0022 The program header format is adequate. 
DOCHB-1.18 Use of code block headers is adequate. 
DOCLC-1.00 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++   95 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     1  = Number of grading runs to get the program working.     
     9  = Number of grading runs to improve efficiency or documentation. 

+- atyC<6&}xC7;&k~C6&juiC86&zuzC?;&Zkyz&jgzk@&6=57:57<&&86@:;@;=&

Building the file arm.ans for electronic submission...
;---------------------------------------------------------------------
; File:     armkey.s
;
; Function: This program copies an ASCII file
;           It assumes the file uses CR/LF as the end of line sequence
;           - It opens an imput file named key.in
;           - It opens an output file named key.out
;           - It reads one line of text from the input file.
;           - It writes that one line to the output file then a CR LF
;           - It loops until it reaches end of file
;           - It closes the input and output file
;
; Author:   Collin Marks
;
; Changes:  Date        Reason
;           ----------------------------------------------------------
;           07/14/2016  Original version
;
;---------------------------------------------------------------------


;----------------------------------
; Software Interrupt values
;----------------------------------
         .equ SWI_Open,  0x66     	;Open  a file
         .equ SWI_Close, 0x68     	;Close a file
         .equ SWI_PrStr, 0x69     	;Write a null-ending string
         .equ SWI_RdStr, 0x6a     	;Read a string and terminate with null char
         .equ SWI_Exit,  0x11     	;Stop execution
;----------------------------------

         .global   _start
         .text

_start:
;----------------------------------
; open input file
; - r0 points to the file name
; - r1 0 for input
; - the open swi is 66h
; - after the open r0 will have the file handle
;----------------------------------
         ldr  r0, =InFileName     	;r0 points to the file name
         ldr  r1, =0              	;r1 = 0 specifies the file is input
         swi  SWI_Open            	;open the file ... r0 will be the file handle
         ldr  r1, =InFileHandle   	;r1 points to handle location
         str  r0, [r1]            	;store the file handle
;----------------------------------


;----------------------------------
; open output file
; - r0 points to the file name
; - r1 1 for output
; - the open swi is 66h
; - after the open r0 will have the file handle
;----------------------------------
         ldr  r0, =OutFileName    	;r0 points to the file name
         ldr  r1, =1              	;r1 = 1 specifies the file is output
         swi  SWI_Open            	;open the file ... r0 will be the file handle
         ldr  r1, =OutFileHandle  	;r1 points to handle location
         str  r0, [r1]            	;store the file handle
;----------------------------------


;----------------------------------
; read a string from the input file
; - r0 contains the file handle
; - r1 points to the input string buffer
; - r2 contains the max number of characters to read
; - the read swi is 6ah
; - the input string will be terminated with 0
;----------------------------------
_process:
         ldr  r0, =InFileHandle   	;r0 points to the input file handle
         ldr  r0, [r0]            	;r0 has the input file handle
         ldr  r1, =InString       	;r1 points to the input string
         ldr  r2, =80           	;r2 has the max size of the input string
         swi  SWI_RdStr           	;read a string from the input file
		 cmp r0, #0x00				; look for EOF seq
		 beq _exit					; if present end program
;----------------------------------

;----------------------------------
; Move the input string to the output string
; This code uses post increment of the input pointer,
; but not for the output pointer ... just to show both techniques
;----------------------------------
         ldr  r0, =InString       	; r0 points to the input  string
         ldr  r1, =OutString      	; r1 points to the output string
_loop:                            	;
		 ldrb r2, [r0], #1        	; get the next input byte
		 cmp r2, #0x00				; we compare to see if null char seq is available
		 beq _finloop				; terminate the program
		 cmp r2, #0X20				; we compare to see if the space char was inputted
		 beq _store					; if it was a space store it to print
		 cmp  r2, #0x7A		 		; compare to z
		 bhi  _loop					; if above z ignore it
		 cmp  r2, #0x60				; compare to lower case a
		 subhi r2, r2, #0X20		; convert to upper
_dontConvert:						;
		 cmp r2, #0x5A				; compare to upper case Z
		 bhi _loop					; if above ignore
		 cmp r2, #0X40				; do 40 bc of only less than
_store:								;
        strhib r2, [r1], #1        	; store it in the output buffer
		b _loop						; continue looping
_finloop: 							;
		strb r2, [r1]				; will effectively load 0
;----------------------------------

;----------------------------------
; Write the outputs string
; Then writes a CR LF pair
;----------------------------------
_print:
         ldr  r0, =OutFileHandle  	; r0 points to the output file handle
         ldr  r0, [r0]            	; r0 has the output file handle
         ldr  r1, =OutString      	; r1 points to the output string
         swi  SWI_PrStr           	; write the null terminated string
         ldr  r1, =CRLF           	; r1 points to the CRLF string
         swi  SWI_PrStr           	; write the null terminated string
		 b _process					; continue processing String
;----------------------------------


;----------------------------------
; Close input and output files
; Terminate the program
;----------------------------------
_exit:                            	;									;
         swi  SWI_Exit            	;terminate the program
;----------------------------------
         .data
;----------------------------------
InFileHandle:  .skip 4            	;4 byte field to hold the input  file handle
OutFileHandle: .skip 4            	;4 byte field to hold the output file handle
									;
InFileName:    .asciz "KEY.IN"   	;Input  file name, null terminated
									;
InString:      .skip 80          	;reserve a 80 byte string for input
OutString:     .skip 80          	;reserve a 80 byte string for output
									;
CRLF:          .byte 13, 10, 0    	;CR LF
									;
OutFileName:   .asciz "KEY.OUT"  	;Output file name, null terminated
;----------------------------------
         .end
