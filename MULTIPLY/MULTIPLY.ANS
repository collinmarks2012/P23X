Test date: 07/06/16  11:07:11 
The number of times you used the grading program is 9 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
Multiply Grading System Version 4.0
Student: Last=Marks                First=Collin               Type=Individual          
Grading and testing history log
       User Test.    Date: 07/01/16  13:27:48  user_test    testout      
       User Test.    Date: 07/04/16  16:01:46  user_test    testout      
       User Test.    Date: 07/05/16  17:58:51  user_test    testout      
       User Test.    Date: 07/05/16  18:48:19  user_test    testout      
       User Test.    Date: 07/05/16  18:48:58  user_test    testout      
       User Test.    Date: 07/05/16  18:49:27  user_test    testout      
       User Test.    Date: 07/05/16  18:56:37  user_test    testout      
       User Test.    Date: 07/05/16  18:58:33  user_test    testout      
       User Test.    Date: 07/05/16  18:59:00  user_test    testout      
       User Test.    Date: 07/05/16  19:04:40  user_test    testout      
   ************************************************** 
   *** Program works correctly.                       
   *** Additional runs are to improve efficiency.     
   *** Completion -- Date: 07/05/16  19:06:28                     
   ************************************************** 
   *** Grading Run.  Date: 07/05/16  19:06:44 
   *** Grading Run.  Date: 07/05/16  19:21:00 
       User Test.    Date: 07/05/16  19:34:07  user_test    testout      
       User Test.    Date: 07/05/16  19:38:45  user_test    testout      
       User Test.    Date: 07/05/16  19:42:55  user_test    testout      
       User Test.    Date: 07/05/16  19:46:19  user_test    testout      
       User Test.    Date: 07/05/16  19:46:52  user_test    testout      
       User Test.    Date: 07/05/16  19:49:45  user_test    testout      
   *** Grading Run.  Date: 07/05/16  19:54:36 
   *** Grading Run.  Date: 07/05/16  20:03:00 
   *** Grading Run.  Date: 07/05/16  20:03:49 
   *** Grading Run.  Date: 07/06/16  10:57:30 
   *** Grading Run.  Date: 07/06/16  11:03:03 
   *** Grading Run.  Date: 07/06/16  11:06:03 
   *** Grading Run.  Date: 07/06/16  11:07:11 

++ Grade ++   40 = Points earned for correct answers.

+  Your executed instruction count per multiply is = 00088
+   
+  Target instructions executed per multiply is:
+  40 points 0000 - 0085 
+  35 points 0086 - 0090 
+  30 points 0091 - 0095 
+  25 points 0096 - 0100 
+  20 points 0101 - 0105 
+  15 points 0106 - 0110 
+  10 points 0111 - 0115 
+   5 points 0116 - 0120 
+   0 points 0121 +      
+                        
++ Grade ++   35 = Points earned for code executed efficiency!

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0021 The program header format is adequate. 
DOCHB-0.62 Use of code block headers is adequate. 
DOCLC-0.99 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++   95 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
    16  = Number of user tests.                                  
     0  = Number of grading runs to get the program working.     
     9  = Number of grading runs to improve efficiency or documentation. 

+- atyC:6&}xC6&k~C9;&juiC86&zuzC?;&Zkyz&jgzk@&6=56<57<&&77@6=@77&

Building the file multiply.ans for electronic submission...

;-----------------------------------------------------------
;
; Program:  MULTIPLY
;
; Function: Multiplies two 16 bit unsigned values ...
;           .... duplicating the MUL instruction
;
; Input:    The two values to be multiplied are passed on the stack
;           The code conforms to the C/C++ calling sequence
;
; Output:   The 32 bit result is returned in the dx:ax pair
;           Registers required by C/C++ need to be saved and restored
;
; Owner:	Collin Marks
;
; Changes:  Date        Reason
;           ------------------
;           07/01/2016  Original version
;
;
;---------------------------------------
         .model    small
         .8086
         public    _multiply
         .data
;---------------------------------------
; Multiply data
;---------------------------------------
         .code
;---------------------------------------
; Multiply code 
; will push registers
; load multiplicand
; load multiplier
; check for multiplication by zero if so exit
; else begin constructing mul operand
;---------------------------------------
_multiply:
        push bp                  		; save bp
        mov  bp, sp               		; anchor bp into the stack
		push di							; save di register
        mov  cx, [bp+4]           		; load multiplicand from the stack
        mov  bx, [bp+6]           		; load multiplier   from the stack
		xor ax, ax 						; check for mul by zero cheap way to zero out reg
		mov dx, ax						; clear out ax and dx
		mov di, cx						; di contains multiplicand
		or di, bx						; test for zero on both regs
										; if all zero then will 
		jz exit							; exit/returing dx:ax which 
										; is both zero at this point
		mov di, ax						; we will use di for reg, reg adc
;---------------------------------------
; Handles multiplication of 1st bit
; and handles carries from previous bit
; then it will handle the next add with carry for next bit
;---------------------------------------	
A:		
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc B							; if no carry go ahead an add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 2nd bit
; and handles carries from previous bit
;---------------------------------------	
B:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc C1							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 3rd bit
; and handles carries from previous bit
;---------------------------------------	
C1:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc D							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 4th bit
; and handles carries from previous bit
;---------------------------------------	
D:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc E							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 5th bit
; and handles carries from previous bit
;---------------------------------------	
E:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc F							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 6th bit
; and handles carries from previous bit
;---------------------------------------	
F:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc G							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 7th bit
; and handles carries from previous bit
;---------------------------------------	
G:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc H							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 8th bit
; and handles carries from previous bit
;---------------------------------------	
H:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc I							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 9th bit
; and handles carries from previous bit
;---------------------------------------			
I:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc J							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 10th bit
; and handles carries from previous bit
;---------------------------------------	
J:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc K							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 11th bit
; and handles carries from previous bit
;---------------------------------------	
K:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc L							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 12th bit
; and handles carries from previous bit
;---------------------------------------	
L:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc M							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 13th bit
; and handles carries from previous bit
;---------------------------------------	
M:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc N							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 14th bit
; and handles carries from previous bit
;---------------------------------------	
N:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc O							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 15th bit
; and handles carries from previous bit
;---------------------------------------	
O:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc P							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16	
;---------------------------------------
; Handles multiplication of 16th and last bit
; and handles carries from previous bit
;---------------------------------------
P:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
		shr cx, 1						; divide by two, bottom bit moved to CF
		jnc Q							; if no carry go ahead and add else handle the CF
		add ax, bx						; add element in bx reg to ax reg
		adc dx, di						; reg, reg is faster than reg, imm16
;---------------------------------------
; Handles multiplication of 1st bit
; and handles carries from previous bit
; then it will handle the next add with carry for next bit
;---------------------------------------			
Q:
		add bx, bx						; will multiply bx by 2
		adc di, di						; carry into di portion of word
;---------------------------------------
; will effectively
; end the program
; ending the multiply subroutine
;---------------------------------------	
exit: 
		pop di
        pop bp               			; restore bp
        ret                           	; return with result in dx:ax
        end                           	; end source code
;---------------------------------------

